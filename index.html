<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sentiment Analyzer</title>
    <!-- 1. Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 2. Set default font to Inter */
        body {
            font-family: "Inter", sans-serif;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 min-h-screen flex flex-col items-center py-10">
    
    <main class="w-full max-w-5xl mx-auto p-4">
        <h1 class="text-3xl font-bold text-center text-gray-900 mb-8">
            Sentiment-based Website Satisfaction Index
        </h1>
        <p class="text-center text-gray-600 mb-10">
            <!-- This is a web-based demo of the vector-based sentiment analysis model. -->
        </p>
        
        <!-- Loading status message -->
        <p id="load_status" class="text-center text-lg text-gray-700 mb-8">
            <!-- Initializing model... -->
        </p>

        <!-- Analysis Cards Container - No longer disabled by default -->
        <div id="analysis_container" class="grid grid-cols-1 md:grid-cols-2 gap-8 opacity-50 pointer-events-none transition-opacity">

            <!-- Card 1: Single Comment Analyzer -->
            <div class="bg-white p-6 rounded-xl shadow-lg flex flex-col">
                <h2 class="text-2xl font-semibold mb-4">Analyze a New Comment</h2>
                
                <div class="flex-grow">
                    <label for="single_comment_text" class="block text-sm font-medium text-gray-700 mb-1">
                        Enter a comment:
                    </label>
                    <textarea id="single_comment_text" rows="4" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 transition" placeholder="e.g., 'This is a great site!'"></textarea>
                    
                    <!-- NEW: Dropdown to select Site ID -->
                    <label for="single_comment_site_id" class="block text-sm font-medium text-gray-700 mt-4 mb-1">
                        Assign to Website ID:
                    </label>
                    <select id="single_comment_site_id" class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 transition">
                        <option value="">-- Select a site --</option>
                        <!-- Options will be dynamically populated -->
                    </select>
                </div>

                <!-- UPDATED: Button text -->
                <button id="analyze_single_btn" class="mt-4 w-full bg-blue-600 text-white p-3 rounded-lg font-semibold shadow hover:bg-blue-700 transition-colors">
                    Analyze & Add to Session
                </button>

                <!-- NEW: Status message -->
                <p id="single_add_status" class="text-center text-sm text-green-600 mt-3"></p>

                <!-- Result area for Single Comment -->
                <div id="single_result_area" class="mt-4 p-4 rounded-lg hidden">
                    <h3 class="font-bold text-lg mb-2">Analysis Result:</h3>
                    <p id="single_result_sentiment" class="text-xl font-semibold mb-2"></p>
                    <div class="text-sm">
                        <p id="single_result_pos_score"></p>
                        <p id="single_result_neg_score"></p>
                    </div>
                </div>
            </div>

            <!-- Card 2: Full Website Satisfaction Index (WSI) -->
            <div class="bg-white p-6 rounded-xl shadow-lg flex flex-col">
                <h2 class="text-2xl font-semibold mb-4">Calculate Full Site WSI</h2>
                
                <div class="flex-grow">
                    <label for="wsi_site_id" class="block text-sm font-medium text-gray-700 mb-1">
                        Select a Website ID to analyze:
                    </label>
                    <select id="wsi_site_id" class="w-full p-2.5 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 transition">
                        <!-- Options will be dynamically populated -->
                        <option value="">-- Loading data... --</option>
                    </select>
                </div>
                
                <button id="analyze_wsi_btn" class="mt-4 w-full bg-indigo-600 text-white p-3 rounded-lg font-semibold shadow hover:bg-indigo-700 transition-colors">
                    Calculate WSI
                </button>

                <!-- Result area for WSI -->
                <div id="wsi_result_area" class="mt-4 p-4 rounded-lg bg-gray-50 hidden">
                    <h3 class="font-bold text-lg mb-3">WSI Analysis Result:</h3>
                    <div class="text-center mb-3">
                        <p class="text-sm text-gray-600">Website Satisfaction Index</p>
                        <p id="wsi_result_score" class="text-4xl font-bold"></p>
                    </div>
                    <div class="space-y-2">
                        <p id="wsi_result_total" class="font-semibold"></p>
                        <div class="w-full bg-gray-200 rounded-full h-2.5">
                            <div id="wsi_progress_bar" class="h-2.5 rounded-full" style="width: 0%"></div>
                        </div>
                        <div class="text-sm text-gray-600 space-y-1">
                            <p id="wsi_result_positive"></p>
                            <p id="wsi_result_neutral"></p>
                            <p id="wsi_result_negative"></p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // --- Global Constants & Data (now dynamic) ---
        const NEUTRALITY_THRESHOLD = 0.1; // (tau)
        let EMBEDDING_DIM = 0;
        let EMBEDDINGS = {};
        let ALL_COMMENTS = [];
        let S_POS = [];
        let S_NEG = [];

        // --- Vector Math Utilities (JavaScript 'numpy') ---
        const vecDot = (v1, v2) => v1.reduce((acc, val, i) => acc + val * v2[i], 0);
        const vecNorm = (v) => Math.sqrt(v.reduce((acc, val) => acc + val * val, 0));
        const vecAdd = (v1, v2) => v1.map((val, i) => val + v2[i]);
        const vecDiv = (v, scalar) => v.map(val => val / scalar);
        const vecZeros = (dim) => Array(dim).fill(0);

        // --- File Parsing Functions ---

        /**
         * Parses the text content of comments.csv
         */
        function parseCSV(text) {
            const comments = [];
            const lines = text.split('\n').filter(line => line.trim().length > 0);
            
            // Skip header
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                // Handle DOS line endings \r
                const cleanLine = line.replace('\r', '');
                if (cleanLine.length === 0) continue;

                const firstCommaIndex = cleanLine.indexOf(',');
                if (firstCommaIndex === -1) continue;

                const id = cleanLine.substring(0, firstCommaIndex).trim();
                let comment = cleanLine.substring(firstCommaIndex + 1).trim();

                // Remove surrounding quotes if they exist
                if (comment.startsWith('"') && comment.endsWith('"')) {
                    comment = comment.substring(1, comment.length - 1);
                }
                
                comments.push({ Website_ID: id, User_Comment: comment });
            }
            return comments;
        }

        /**
         * Parses the text content of embeddings.txt
         */
        function parseEmbeddings(text) {
            const embeddings = {};
            const lines = text.split('\n').filter(line => line.trim().length > 0);
            let dim = 0;
            
            for (const line of lines) {
                try {
                    // Handle DOS line endings \r
                    const cleanLine = line.replace('\r', '');
                    if (cleanLine.length === 0) continue;
                    
                    const parts = cleanLine.split(' ');
                    const word = parts[0];
                    const vector = parts.slice(1).map(Number);
                    
                    if (vector.length > 0) {
                        embeddings[word] = vector;
                        if (dim === 0) {
                            dim = vector.length;
                        }
                    }
                } catch (e) {
                    console.warn("Skipping bad embedding line:", line);
                }
            }
            return [embeddings, dim];
        }


        // --- Ported Python Functions ---

        /**
         * Calculates the cosine similarity between two vectors.
         */
        function cosineSimilarity(v1, v2) {
            const norm_v1 = vecNorm(v1);
            const norm_v2 = vecNorm(v2);
            if (norm_v1 === 0 || norm_v2 === 0) {
                return 0.0;
            }
            const dotProduct = vecDot(v1, v2);
            return dotProduct / (norm_v1 * norm_v2);
        }

        /**
         * Calculates s_pos and s_neg by averaging seed word vectors.
         */
        function calculateReferenceVectors() {
            const POSITIVE_SEED_WORDS = ['good', 'great', 'love', 'excellent', 'best', 'awesome', 'happy'];
            const NEGATIVE_SEED_WORDS = ['bad', 'terrible', 'hate', 'worst', 'awful', 'poor', 'sad'];

            function getAverageVector(words) {
                let vectorSum = vecZeros(EMBEDDING_DIM);
                let wordCount = 0;
                for (const word of words) {
                    if (EMBEDDINGS[word]) {
                        vectorSum = vecAdd(vectorSum, EMBEDDINGS[word]);
                        wordCount++;
                    }
                }
                if (wordCount === 0) {
                    return vecZeros(EMBEDDING_DIM);
                }
                return vecDiv(vectorSum, wordCount);
            }

            S_POS = getAverageVector(POSITIVE_SEED_WORDS);
            S_NEG = getAverageVector(NEGATIVE_SEED_WORDS);
        }

        /**
         * Basic text cleaning: lowercase, remove punctuation, split into words.
         */
        function cleanText(text) {
            if (typeof text !== 'string' || !text) {
                return [];
            }
            return text.toLowerCase()
                       .replace(/[^\w\s]/g, '') // Remove punctuation
                       .split(/\s+/) // Split by whitespace
                       .filter(word => word.length > 0); // Remove empty strings
        }

        /**
         * Creates the Document Vector (d) by averaging its word vectors.
         */
        function createDocumentVector(words) {
            let d = vecZeros(EMBEDDING_DIM);
            let wordCount = 0;
            for (const word of words) {
                if (EMBEDDINGS[word]) {
                    d = vecAdd(d, EMBEDDINGS[word]);
                    wordCount++;
                }
            }
            if (wordCount > 0) {
                d = vecDiv(d, wordCount);
            }
            return d;
        }

        /**
         * Applies the final classification rule from section 3.2.
         * Returns [label, sim_pos, sim_neg]
         */
        function classifySentiment(d, s_pos, s_neg, tau) {
            if (vecNorm(d) === 0) {
                return ["Neutral", 0.0, 0.0];
            }
            
            const sim_pos = cosineSimilarity(d, s_pos);
            const sim_neg = cosineSimilarity(d, s_neg);
            
            if (sim_pos > sim_neg + tau) {
                return ["Positive", sim_pos, sim_neg];
            } else if (sim_neg > sim_pos + tau) {
                return ["Negative", sim_pos, sim_neg];
            } else {
                return ["Neutral", sim_pos, sim_neg];
            }
        }
        
        /**
         * Calculates the Website Satisfaction Index (WSI) from section 3.2.
         * Returns [wsi, total_count]
         */
        function calculateWSI(counts) {
            const count_pos = counts['Positive'] || 0;
            const count_neu = counts['Neutral'] || 0;
            const count_neg = counts['Negative'] || 0;
            
            const count_total = count_pos + count_neu + count_neg;
            if (count_total === 0) {
                return [0.0, 0];
            }
            
            const numerator = (count_pos * 1) + (count_neg * -1);
            const wsi = (numerator / count_total) * 100.0;
            return [wsi, count_total];
        }

        // --- Main Application Logic ---

        // NEW: Load data on page load
        document.addEventListener('DOMContentLoaded', async () => {
            
            const loadStatus = document.getElementById('load_status');
            const analysisContainer = document.getElementById('analysis_container');
            const wsiSiteIdSelect = document.getElementById('wsi_site_id');
            // NEW: Get the new dropdown
            const singleSiteIdSelect = document.getElementById('single_comment_site_id');

            try {
                // loadStatus.textContent = "Loading comments.csv and mock_embeddings.txt...";
                
                // 1. Fetch files from the local server
                const [commentsResponse, embeddingsResponse] = await Promise.all([
                    fetch('comments.csv'),
                    fetch('mock_embeddings.txt')
                ]);

                if (!commentsResponse.ok) {
                    throw new Error(`Failed to load comments.csv: ${commentsResponse.statusText}`);
                }
                if (!embeddingsResponse.ok) {
                    throw new Error(`Failed to load mock_embeddings.txt: ${embeddingsResponse.statusText}`);
                }

                const commentsText = await commentsResponse.text();
                const embeddingsText = await embeddingsResponse.text();

                // 2. Process data
                ALL_COMMENTS = parseCSV(commentsText);
                [EMBEDDINGS, EMBEDDING_DIM] = parseEmbeddings(embeddingsText);

                // 3. Calculate reference vectors
                calculateReferenceVectors();

                // 5. Populate Website_ID dropdowns
                const siteIds = [...new Set(ALL_COMMENTS.map(c => c.Website_ID))];
                wsiSiteIdSelect.innerHTML = ''; // Clear default
                singleSiteIdSelect.innerHTML = '<option value="">-- Select a site --</option>'; // Clear default

                siteIds.forEach(id => {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = id;
                    // Add to both dropdowns
                    wsiSiteIdSelect.appendChild(option.cloneNode(true));
                    singleSiteIdSelect.appendChild(option.cloneNode(true));
                });

                // 6. Enable analysis cards
                analysisContainer.classList.remove('opacity-50', 'pointer-events-none');

            } catch (error) {
                console.error("Error loading files:", error);
                loadStatus.textContent = `Error initializing model: ${error.message}. Make sure you are running 'python -m http.server' and have the files in the same folder.`;
                loadStatus.classList.add('text-red-600');
            }


            // --- Handler for Single Comment Analysis ---
            const analyzeSingleBtn = document.getElementById('analyze_single_btn');
            const commentText = document.getElementById('single_comment_text');
            const resultArea = document.getElementById('single_result_area');
            const resultSentiment = document.getElementById('single_result_sentiment');
            const resultPosScore = document.getElementById('single_result_pos_score');
            const resultNegScore = document.getElementById('single_result_neg_score');
            // NEW: Get the new elements
            const singleSiteId = document.getElementById('single_comment_site_id');
            const singleAddStatus = document.getElementById('single_add_status');

            analyzeSingleBtn.addEventListener('click', () => {
                const text = commentText.value;
                // NEW: Get selected site ID
                const selectedSiteId = singleSiteId.value;

                // NEW: Clear status message
                singleAddStatus.textContent = '';

                // NEW: Validation
                if (!text || !selectedSiteId) {
                    singleAddStatus.textContent = "Please enter a comment and select a site.";
                    singleAddStatus.classList.remove('text-green-600');
                    singleAddStatus.classList.add('text-red-600');
                    return;
                }
                
                // Run the analysis
                const words = cleanText(text);
                const d = createDocumentVector(words);
                const [label, sim_pos, sim_neg] = classifySentiment(d, S_POS, S_NEG, NEUTRALITY_THRESHOLD);

                // Display results
                resultSentiment.textContent = label;
                resultPosScore.textContent = `Positive Similarity: ${sim_pos.toFixed(4)}`;
                resultNegScore.textContent = `Negative Similarity: ${sim_neg.toFixed(4)}`;

                // Remove old color classes
                resultArea.classList.remove('bg-green-100', 'text-green-800', 'bg-red-100', 'text-red-800', 'bg-yellow-100', 'text-yellow-800', 'hidden');
                resultArea.classList.remove('hidden'); // Show the area

                // Add new color classes based on sentiment
                if (label === 'Positive') {
                    resultArea.classList.add('bg-green-100', 'text-green-800');
                } else if (label === 'Negative') {
                    resultArea.classList.add('bg-red-100', 'text-red-800');
                } else {
                    resultArea.classList.add('bg-yellow-100', 'text-yellow-800');
                }

                // NEW: Add the comment to the in-memory array
                ALL_COMMENTS.push({
                    Website_ID: selectedSiteId,
                    User_Comment: text
                });
                
                // NEW: Show success message
                singleAddStatus.textContent = `Comment added to '${selectedSiteId}' for this session.`;
                singleAddStatus.classList.add('text-green-600');
                singleAddStatus.classList.remove('text-red-600');

                // Optional: Clear the text box
                // commentText.value = '';
            });

            // --- Handler for Full WSI Analysis ---
            const analyzeWsiBtn = document.getElementById('analyze_wsi_btn');
            const wsiResultArea = document.getElementById('wsi_result_area');
            const wsiScore = document.getElementById('wsi_result_score');
            const wsiTotal = document.getElementById('wsi_result_total');
            const wsiPositive = document.getElementById('wsi_result_positive');
            const wsiNeutral = document.getElementById('wsi_result_neutral');
            const wsiNegative = document.getElementById('wsi_result_negative');
            const wsiProgressBar = document.getElementById('wsi_progress_bar');

            analyzeWsiBtn.addEventListener('click', () => {
                const targetSite = wsiSiteIdSelect.value;
                if (!targetSite) {
                    // This case should no longer happen, but good to keep.
                    alert("Please load data and select a site first.");
                    return;
                }
                
                // 1. Filter comments for the target site
                const siteComments = ALL_COMMENTS.filter(c => c.Website_ID === targetSite);
                
                // 2. Classify each comment
                const counts = { 'Positive': 0, 'Neutral': 0, 'Negative': 0 };
                for (const comment of siteComments) {
                    const words = cleanText(comment.User_Comment);
                    const d = createDocumentVector(words);
                    const [label, _pos, _neg] = classifySentiment(d, S_POS, S_NEG, NEUTRALITY_THRESHOLD);
                    counts[label]++;
                }
                
                // 3. Calculate WSI
                const [wsi, total] = calculateWSI(counts);
                const count_pos = counts['Positive'];
                const count_neu = counts['Neutral'];
                const count_neg = counts['Negative'];

                // 4. Display WSI results
                wsiScore.textContent = `${wsi.toFixed(2)}`;
                wsiTotal.textContent = `Based on ${total} total comments`;

                const pos_pct = total > 0 ? (count_pos / total * 100) : 0;
                const neu_pct = total > 0 ? (count_neu / total * 100) : 0;
                const neg_pct = total > 0 ? (count_neg / total * 100) : 0;
                
                wsiPositive.textContent = `Positive: ${count_pos} (${pos_pct.toFixed(1)}%)`;
                wsiNeutral.textContent = `Neutral: ${count_neu} (${neu_pct.toFixed(1)}%)`;
                wsiNegative.textContent = `Negative: ${count_neg} (${neg_pct.toFixed(1)}%)`;

                // Update progress bar
                const bar_pct = (wsi + 100) / 2;
                wsiProgressBar.style.width = `${bar_pct}%`;
                
                // Update colors
                wsiProgressBar.classList.remove('bg-green-600', 'bg-red-600', 'bg-yellow-600');
                wsiScore.classList.remove('text-green-600', 'text-red-600', 'text-gray-700');

                if (wsi > 20) {
                    wsiProgressBar.classList.add('bg-green-600');
                    wsiScore.classList.add('text-green-600');
                } else if (wsi < -20) {
                    wsiProgressBar.classList.add('bg-red-600');
                    wsiScore.classList.add('text-red-600');
                } else {
                    wsiProgressBar.classList.add('bg-yellow-600');
                    wsiScore.classList.add('text-gray-700');
                }

                wsiResultArea.classList.remove('hidden');
            });
        });
    </script>
</body>
</html>